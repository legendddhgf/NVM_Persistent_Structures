\documentclass[twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{lipsum}                     % Dummytext
\usepackage{hyperref}
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{float}
\usepackage{tikz-qtree}
\usepackage{tikz}
\usepackage[linguistics]{forest}

\usepackage{amssymb}
\usepackage{amsmath}
\newcommand*{\QEDA}{\hfill\ensuremath{\blacksquare}}% filled box
\newcommand*{\QEDB}{\hfill\ensuremath{\square}}% unfilled box

% dem nice tables
\usepackage[hmargin=2cm,top=4cm,headheight=65pt,footskip=65pt]{geometry}
\usepackage{fmtcount} % for \ordinalnum
\usepackage{array,multirow}
\usepackage{tabularx}
\usepackage{lastpage}


% add a special collumn type
\newcolumntype{C}[1]{>{\centering\arraybackslash}m{#1}}


%header/footer stuff
\usepackage{fancyhdr}
\pagestyle{fancy}

%note that if you do not do these blank ones, the package defaults to something
%you may not want in your header or footer
\lhead{CMPE 293}
\chead{}
\rhead{\today}
\lfoot{Isaak Cherdak}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

\usepackage[english]{babel}
\emergencystretch=1pt
\usepackage[justification=centering]{caption}
\graphicspath{{Pictures/} }

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%\usepackage{setspace}
%\doublespacing

\title{A Comparison of Persistent Data Structures for Non-Volatile Memory
Applications}
\author{Isaak Cherdak}
%\date{} %blank date

\begin{document}

\maketitle

\section*{Abstract}

With the introduction of byte-addressable persistent memory comes the need to
rethink the way that data in memory is interfaced and structured. At the heart
of this research is the consideration of various persistent data structures.
This paper seeks to determine the benefits and trade-offs of four different
persistent data structures and suggest scenarios in which each one is best
utilized.

\pagebreak

\section*{Important terms and notations}

\todo[inline]{make this into a nice table}

The indexing scheme in all parts of this report starts at 0

\todo[inline]{setup bibtek crap}

\section{Introduction}

Non-volatile memory (NVM) systems research has become a major research focus in
Computer Science. NVM provides the possibility of byte-addressable memory that
persists across power cycles while maintaining latencies similar to that of
DRAM. Although NVM technologies have yet to reach their intended potential,
there are a number of topics of theoretical research that can be done so that
NVM can be fully utilized once it is more accessible. For example, with volatile
memory, any corruption or bugs present in memory can be cleared with a power
cycle but with NVM this is no longer an option. Thus, one requirement of
structuring data in NVM is the use of persistent data structures, or data
structures whose state cannot be invalidated. However, there are many data
structures to choose from and the potential for new ones to be created with
particular design focus (i.e. batch read optimized).

This paper will compare four different persistent data structures in various
scenarios. First some background on major non-volatile memory system research
concerns will be discussed. Then the various scenarios used to compare data
structures in this paper are described including their uses in both consumer and
business environments. Next the implementation of the data structures is
discussed including informal proof of their persistent correctness. Finally the
paper discusses results of the comparisons and concludes with suggestions for
the structures and a general statement about what these results mean about
certain properties of certain kinds of data structures.

\section{Background}

\subsection{Non-Volatile Memory Based Systems}

Non-Volatile Memory Systems promise to provide memory that can survive power
cycles with the latency of DRAM. \todo[inline]{cite}
However, they come with a number of concerns such as the persistence of bugs in
the kernel or applications even after reboot.

\subsection{Software For NVM}

\todo[inline]{mention shadow updates (I believe mnemosyne did a good job of
describing these).}

\subsection{Analysis of Data}

Results from any test should be accurate, precise, and reproducible.
\todo[inline]{Need to discuss slightly more in depth and cite pilot here.}

\section{Methodology}

\todo[inline]{dunno if I will keep this section. I think if I do, it will
probably just discuss my general approach to the project which may be clear from
reading the rest of the paper anyway}

\section{Implementation}

\subsection{Overview}

\todo[inline]{structure everything like a K/V store: perhaps just turn the
Generic datatype into a struct containing a key and value}

\todo[inline]{this is what I plan to do}

I use gettimeofday() to collect data on runtime and a series of sizeof() calls
to determine memory usage.  I used Intel's guide on emulating persistent memory
with ordinary DRAM to emulate persistent memory performance, functionality, and
primarily timings. (tutorial can be found here
\url{https://software.intel.com/en-us/articles/how-to-emulate-persistent-memory-on-an-intel-architecture-server/})

The memory range used to be mapped as pmem was 1G to 3G on my laptop.

I focused on making things persistent (invalid state not possible). I also
used clwb
(\url{https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=clwb&expand=662}
from intrinsics refernce).
\todo[inline]{probably will do something slightly different}

I made use of libpmemobj for memory transactions (allocations/frees):
\url{http://pmem.io/pmdk/libpmemobj/}
which can be downloaded and installed with the entire PMDK intel library here:
\url{https://github.com/pmem/pmdk}

I further used pilot to aid in analysis of the results and structuring the
benchmark.

Some functions listed in each data structure's documentation later in this
section are only those that I have standardized and required for each as a
critical operation used by the benchmark to generate results. Note that these
functions may have different uses or ignore some of their parameters: this is
also normal as data structures may differ in the information needed up front
during different operations (i.e: indices in BTrees).

Finally, note that some of these functions are unimplemented or untested but
described for the sake of future work. Such functions will warn of this within
the first section or so.

\subsection{Main}

Calls Benchmark. Originally, was intended to be used to work with libpilot and
still be able to natively call C code. The use of pilot in this project is
described in (reference\_to\_section).

\subsection{Benchmark}

This is the main program. It is called from Main which is a C++ program. The
benchmark facilitates the black box tests on the data structures. These tests
are timed and are the results sent to a file for each test.

\subsection{Singly Linked List}

The persistent Singly Linked List focuses on constructing nodes before
connecting them to the rest of the data structure. A list, or more specifically
the head of a list, is defined to be a pointer to a node. Some functions may
take list pointers to maintain standardization of the functions with different
data structures and to allow changing the head of the list.

\subsubsection{Init}

A list of size 0, or an empty list is one where the list variable is set to
NULL. Hence, the init function for the list simply sets the list variable to
NULL. Guaranteed persistence of this function is also trivial. Thus, the list
takes very little constant time and space to initialize.

\subsubsection{Insert}

The insert function adds a piece of data at a specified location. An item can be
added at any location that already exists or at index = size to append.
Alternatively, index = -1 means to append as well. An insert will place an item
at the specified index and "re-label" items that previously were located in the
range $[index,size-1]$ to $[index+1,size]$, hence increasing the size by 1 as
well. "Re-label"-ing of these items is simply the result of their new placement
relative to the head of the list and not a separate operation. Alternatively,
providing a true value to the sorted parameter will ignore the index and ensure
a sorted insert.

This function can also be proven persistent. Up till the point that the main
list is updated, all updates are done in the background to a single node. Hence
upon crashing, a node is either not added / leaked, or the list is successfully
updated since it takes a single pointer (either changing head or changing a next
pointer). Finally, the insert function has a worst case runtime of O(size) and
space usage of O(1) since iterating through the whole list may be required and
space usage will at most be that of a single node, regardless of the list's
size.

\subsubsection{Update}

\todo[inline]{I just came up with this function and realized that it is
significant and common in practice. Thus, obviously the following describes how
I \textit{will} do it rather than how I \textit{did} do it}

The update function changes an entry in the list whose key matches the requested
key. If the entry does not yet exist, an entry is appended or inserted in sorted
order depending on whether the sorted parameter is false or true respectively.
Updating data in a node requires the creation of the updated node as a shadow
update. Hence on crashing, the list will either look the same as before the call
to update or will persist the change from update. A crash may still result in a
memory leak even if the requested update persists. Finally, since Insert is
already proven to be persistent, update is also persistent. The runtime of
update is bounded above by Insert's runtime and hence has the same asymptotic
worst case runtime as that of Insert.

\subsubsection{Delete}

This function was not implemented. Delete an entry.

\subsubsection{Destroy}

Destroy the list
TODO: make the destroy functions persistent by taking the NULL overwrite and
putting it at the very beginning instead of the end

\subsubsection{GetElement}

This function iterates over the list and returns the item at the provided index
in unsorted mode. Sorted mode wasn't implemented but would have returned the
element for a key or NULL if the key wasn't found.

\subsubsection{GetMemSize}

Adds sizeof(SLLNode) for every single node while iterating.

\subsection{Vector}

The vector maintains a pointer to a contiguous block of memory which doubles in
size as necessary. The vector uses an extra entry which also contains the
current capacity of the vector. This is so insertion locations can be determined
instantly or at the very least, one can determine the number of times the vector
should double in advance.

\subsubsection{Init}

This function allocates a contiguous block of memory with a given starting size.

\subsubsection{Insert}

The unsorted version of this function simply adds an item at a given index to
the block pointed to by the vector. If the item is to be placed outside of the
current maximum capacity of the block, then the block is reallocated and the
original values stored in the new block. The vector then is set to point to the
new block and the old block is freed. Since this function only overwrites
elements in persisted blocks or changes a pointer to another persisted block,
this function is also persistent. This function runs in worst case O(n) time
since copying a block to another block requires iterating for the size of the
block.

The sorted insert was not implemented. Sorted insert requires shifting of all
data to the right of the insertion location within the vector. To make this
persistent would be even slower since it would require a full copy into a new
vector and a final change of the vector block pointer.

\subsubsection{Update}

This is equivalent to unsorted insert.

\subsubsection{Delete}

This function wasn't implemented. Delete would simply set an entry to
uninitialized value. If the entry (or index) is out of the range of the current
capacity then nothing happens. Unlike insert which may double the size of the
block, this function leaves the block as is.

\subsubsection{Destroy}

This free the memory associated with the block and sets the block pointer to
point to NULL.

\subsubsection{GetElement}

Returns NULL if request is out of capacity boundary or unset and returns the
item otherwise.

\subsubsection{GetMemSize}

sizeof(entry) * (capacity + 1)

\subsection{LSM Tree}

The LSM tree was provided by harvard PhD (NAME\_HERE). The repository can be
found here (LINK). The LSM Tree inserts up to a certain prespecified number of
items into memory and then into disk once memory goes over capacity. Finally
note that this data structure hasn't been modified to be perfectly persistent.
in other words, even with persist calls, there are instances where multiple
pieces of persisted data may not be consistent with each other.

\subsubsection{Init}

This calls the LSM tree init function which does basic initialization and
allocation of various data blocks.

\subsubsection{Insert}

If there is space in the memory buffer, insertion occurs there. Otherwise, a
merge is performed between curent disk and buffer content and writes are done to
the disk accordingly.

\subsubsection{Delete}

This function wasn't used and isn't tested.

\subsubsection{GetElement}

First checks the memory buffer for the data and then the disk. Worst case will
return NULL

\subsubsection{GetMemSize}

Returns the size of the memory buffer block which is sizeof(LSMNode) *
memory\_buffer\_size.

\subsection{BTree}

Like the list implementation, the BTree is defined to be a pointer to a node and
is NULL when empty. The BTree operates on the rule that given an order, it has
$[order, 2 * order]$ keys and $[order + 1, 2 * order + 1]$ children per node.
The keys should be thought of as separators in the sense that values between the
keys are contained in the children between key locations. Finally, the above
rule about minimum keys doesn't apply to the root and the above rule about
minimum children doesn't apply to leaves. Also note this is the only data
structure that has no unsorted mode because of the nature of how it is
constructed.

\subsubsection{Init}

The BTree is initialized by being set to NULL. Hence, it has the same trivial
guaranteed persistence and runtime as the list's Init function.

\subsubsection{Insert}

The BTree's insert attempts to insert a key into a leaf node. To determine the
leaf node in question, the correct child node is iterated, based off key range.
If the leaf node is full, a complicated series of operations ensue to split
nodes from the leaf potentially all the way up to the root. These split
operations create a new node and splits left and right sides of the old node
such that each has the minimum number of keys/children and the parent recieves
the median. The set of entries considered for the aforementioned split includes
the insertion entry. The functions are all carefully designed to ensure that the
data structure is persistent.

\subsubsection{Update}

This function was not implemented. Only needs to replace data in a node. As a
result, we only need to copy the node, modify the value for the key in the copy
and then have the node's parent (or the head if this is the root) change
pointers to reflect the updated node. If the data doesn't yet exist, an insert
is performed instead.

\subsubsection{Delete}

This function was not implemented. a k/v entry based off the key argument is
removed. If the entry is in a non-leaf node, then you may have to perform a
recursive merge on the tree to maintain basic properties.

\subsubsection{Destroy}

Recusrively iterates to every node and every node destroys (frees) itself at the
end of its own recursive call.

\subsubsection{GetElement}

If a key isn't found, determines which child to search based of key range.
Returns value if key is found and NULL otherwise.

\subsubsection{GetMemSize}

Recursively get the number of nodes and multiplies by sizeof(BTNode).

\section{Results}

Used my laptop... to get some basic results.

Tried a friend's custom intel build...difficulty with emulation of pmem

Got some results, will get even more with different values.

Unfortunately, there isn't enough variety of tests to come to much of a
conclusion but the differences can be summed to the following. Note that
currently there exists only a sequential insertion of numbers in a particular
range followed by a sequential set of calls to verify that all elements can
still be found inside the respective data structures.

\section{Major Challenges}

\subsection{Utilizing persistent memory with a familiar format}

Being able to allocate, free, and request persistence of data in a familiar
format is extremely important for code portability. However, the Persistent
Memory Development Kit (PMDK) has a lot of features and requirements than those
usually needed by malloc/free. As a result, I came up with a wrapper that would
allow you to call allocation or free in the same way and the actual operation
can be changed through a different define. This enabled the easy running and
comparison of data structures in persistent and normal memory modes.

\subsection{Configuration}

Very careful consideration has to be made to ensure that everything is
configured correctly. For example, pmem test results are so much slower if you
don't correctly emulate persistent memory and mount onto the location used for
the persistent memory pool. A major issue that I had been runnning into is the
kernel code utilizing blocks between those that you specify as NVRAM. Such
blocks will not have a device in /dev created and as such will have no use. One
way that I found gave a good chance of recieving a functioning memory segment
was to split a large segment into multiple small ones so that hopefully at
least one will be available after you reboot the new grub configuration.

\section{Conclusion}

\section{Citation Info}

\todo[inline]{This section is temporary and should be made using bibtek later}

sources to consider:

BTrees:\\
\url{https://dl.acm.org/citation.cfm?doid=356770.356776}

figuring out the mix of C and C++:\\
\url{https://isocpp.org/wiki/faq/mixing-c-and-cpp}

\end{document}
