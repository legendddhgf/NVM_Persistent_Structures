\documentclass[twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{lipsum}                     % Dummytext
\usepackage{hyperref}
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{float}
\usepackage{tikz-qtree}
\usepackage{tikz}
\usepackage[linguistics]{forest}

\usepackage{amssymb}
\usepackage{amsmath}
\newcommand*{\QEDA}{\hfill\ensuremath{\blacksquare}}% filled box
\newcommand*{\QEDB}{\hfill\ensuremath{\square}}% unfilled box

% dem nice tables
\usepackage[hmargin=2cm,top=4cm,headheight=65pt,footskip=65pt]{geometry}
\usepackage{fmtcount} % for \ordinalnum
\usepackage{array,multirow}
\usepackage{tabularx}
\usepackage{lastpage}


% add a special collumn type
\newcolumntype{C}[1]{>{\centering\arraybackslash}m{#1}}


%header/footer stuff
\usepackage{fancyhdr}
\pagestyle{fancy}

%note that if you do not do these blank ones, the package defaults to something
%you may not want in your header or footer
\lhead{CMPE 293}
\chead{}
\rhead{\today}
\lfoot{Isaak Cherdak}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

\usepackage[english]{babel}
\emergencystretch=1pt
\usepackage[justification=centering]{caption}
\graphicspath{{Pictures/} }

\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%\usepackage{setspace}
%\doublespacing

\title{A Comparison of Persistent Data Structures for Non-Volatile Memory
Applications}
\author{Isaak Cherdak}
%\date{} %blank date

\begin{document}

\maketitle

\section*{Abstract}

With the introduction of byte-addressable persistent memory comes the need to
rethink the way that data in memory is interfaced and structured. At the heart
of this research is the consideration of various persistent data structures.
This paper seeks to determine the benefits and trade-offs of five different
persistent data structures and suggest scenarios in which each one is best
utilized.

\pagebreak

\section*{Important terms and notations}

\todo[inline]{make this into a nice table}

The indexing scheme in all parts of this report starts at 0

\todo[inline]{setup bibtek crap}

\section{Introduction}

Non-volatile memory (NVM) systems research has become a major focus. NVM
provides the possibility of byte-addressable memory that persists across power
cycles while maintaining latencies similar to that of DRAM. Although NVM
technologies have yet to reach their intended potential, there are a number of
topics of theoretical research that can be done so that NVM can be fully
utilized once it is more accessible. For example, with volatile memory, any
corruption or bugs present in memory can be cleared with a power cycle but with
NVM this is no longer an option. Thus, one requirement of structuring data in
NVM is the use of persistent data structures, or data structures whose state
cannot be invalidated. However, there are many data structures to choose from
and the potential for new ones to be created with particular design focus (i.e.
batch read optimized).

This paper will compare four different persistent data structures in various
scenarios. First some background on major non-volatile memory system research
concerns will be discussed. Then the various scenarios used to compare data
structures in this paper are described including their uses in both consumer and
business environments. Next the implementation of the data structures is
discussed including informal proof of their persistent correctness. Finally the
paper discusses results of the comparisons and concludes with suggestions for
the structures and a general statement about what these results mean about
certain properties of certain kinds of data structures.

\section{Background}

\subsection{Non-Volatile Memory Based Systems}

Non-Volatile Memory Systems promise to provide memory that can survive power
cycles with the latency of DRAM. \todo[inline]{cite}
However, they come with a number of concerns.

\subsection{Software For NVM}

\todo[inline]{mention shadow updates (I believe mnemosyne did a good job of
describing these).}

\section{Methodology}

\todo[inline]{dunno if I will keep this section. I think if I do, it will
probably just discuss my general approach to the project which may be clear from
reading the rest of the paper anyway}

\section{Implementation}

\subsection{Overview}

\todo[inline]{structure everything like a K/V store: perhaps just turn the
Generic datatype into a struct containing a key and value}

\todo[inline]{this is what I plan to do}

I used cachegrind (or perhaps just used timers of some sort?) to collect data
and used the Intel's guide on emulating persistent memory with ordinary DRAM to
emulate persistent memory performance, functionality, and primarily timings.
(tutorial can be found here
\url{https://software.intel.com/en-us/articles/how-to-emulate-persistent-memory-on-an-intel-architecture-server/})

The memory range used to be mapped as pmem was 1G to 3G


I focused on making things persistent (invalid state not possible). I also
used clwb
(\url{https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=clwb&expand=662}
from intrinsics refernce).
\todo[inline]{probably will do something slightly different}

I made use of libpmemobj for memory transactions (allocations/frees):
\url{http://pmem.io/pmdk/libpmemobj/}
which can be downloaded and installed with the entire PMDK intel library here:
\url{https://github.com/pmem/pmdk}

I further used pilot to aid in analysis of the results and structuring the
benchmark.

Finally, note that functions listed in each data structure's documentation later
in this section are only those that I have standardized and required for each as
a critical operation used by the benchmark to generate results. Note that these
functions may have different uses or ignore some of their parameters: this is
also normal as data structures may differ in the information needed up front
during different operations (i.e: indices in BTrees)

\subsection{Benchmark}

\subsection{Singly Linked List}

The persistent Singly Linked List focuses on constructing nodes before
connecting them to the rest of the data structure. A list, or more specifically
the head of a list, is defined to be a pointer to a node. Some functions may
take list pointers to maintain standardization of the functions with different
data structures and to allow changing the head of the list.

\subsubsection{Init}

A list of size 0, or an empty list is one where the list variable is set to
NULL. Hence, the init function for the list simply sets the list variable to
NULL. Guaranteed persistence of this function is also trivial. Thus, the list
takes very little constant time and space to initialize.

\subsubsection{Insert}

The insert function adds a piece of data at a specified location. An item can be
added at any location that already exists or at index = size to append.
Alternatively, index = -1 means to append as well. An insert will place an item
at the specified index and "re-label" items that previously were located in the
range $[index,size-1]$ to $[index+1,size]$, hence increasing the size by 1 as
well. "Re-label"-ing of these items is simply the result of their new placement
relative to the head of the list and not a separate operation. Alternatively,
providing a true value to the sorted parameter will ignore the index and ensure
a sorted insert.

This function can also be proven persistent. Up till the point that the main
list is updated, all updates are done in the background to a single node. Hence
upon crashing, a node is either not added / leaked, or the list is successfully
updated since it takes a single pointer (either changing head or changing a next
pointer). Finally, the insert function has a worst case runtime of O(size) and
space usage of O(1) since iterating through the whole list may be required and
space usage will at most be that of a single node, regardless of the list's
size.

\subsubsection{Update}

\todo[inline]{I just came up with this function and realized that it is
significant and common in practice. Thus, obviously the following describes how
I \textit{will} do it rather than how I \textit{did} do it}

The update function changes an entry in the list whose key matches the requested
key. If the entry does not yet exist, an entry is appended or inserted in sorted
order depending on whether the sorted parameter is false or true respectively.
Updating data in a node requires the creation of the updated node as a shadow
update. Hence on crashing, the list will either look the same as before the call
to update or will persist the change from update. A crash may still result in a
memory leak even if the requested update persists. Finally, since Insert is
already proven to be persistent, update is also persistent. The runtime of
update is bounded above by Insert's runtime and hence has the same asymptotic
worst case runtime as that of Insert.

\subsection{Delete}

Delete an entry

\subsection{Destroy}

Destroy the list
TODO: make the destroy functions persistent by taking the NULL overwrite and
putting it at the very beginning instead of the end

\subsection{Vector}

The vector maintains a contiguous block of memory which doubles in size as
necessary.

\subsubsection{Init}

This function allocates a contiguous block of memory with a given starting size.

\subsubsection{Insert}

The unsorted version of this function simply adds an item at a given index to
the block pointed to by the vector. If the item is to be placed outside of the
current maximum capacity of the block, then the block is reallocated and the
original values stored in the new block. The vector then is set to point to the
new block and the old block is freed. Since this function only overwrites
elements in persisted blocks or changes a pointer to another persisted block,
this function is also persistent. This function runs in worst case O(n) time
since copying a block to another block requires iterating for the size of the
block.

\dots

the sorted insert may require shifting of some portion of the contiguous block
of memory.

\subsubsection{Update}

This is equivalent to unsorted insert.

\subsubsection{Delete}

\subsubsection{Destroy}

\subsection{BTree}

Like the list implementation, the BTree is defined to be a pointer to a node and
is NULL when empty.

\subsubsection{Init}

The BTree is initialized by being set to NULL. Hence, it has the same trivial
guaranteed persistence and runtime as the list's Init function.

\subsubsection{Insert}

\subsubsection{Update}

Only needs to replace data in a node. As a result, we only need to copy the
node, modify the value for the key in the copy and then have the node's parent
(or the head if this is the root) change pointers to reflect the updated node.
If the data doesn't yet exist, an insert is performed instead.

\subsubsection{Delete}

\subsubsection{Destroy}

\section{Results}

\section{Conclusion}

\section{Citation Info}

\todo[inline]{This section is temporary and should be made using bibtek later}

sources to consider:

BTrees:\\
\url{https://dl.acm.org/citation.cfm?doid=356770.356776}


\end{document}
